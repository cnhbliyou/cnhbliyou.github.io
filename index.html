<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cnhbliyou.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="riyuu 的个人博客">
<meta property="og:url" content="http://cnhbliyou.github.io/index.html">
<meta property="og:site_name" content="riyuu 的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="riyuu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://cnhbliyou.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>riyuu 的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">riyuu 的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cnhbliyou.github.io/2023/07/19/%E6%AF%94%E4%BE%8B%E9%85%8D%E9%A2%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="riyuu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="riyuu 的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/19/%E6%AF%94%E4%BE%8B%E9%85%8D%E9%A2%9D/" class="post-title-link" itemprop="url">比例配额</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-07-19 15:06:17 / 修改时间：15:31:56" itemprop="dateCreated datePublished" datetime="2023-07-19T15:06:17+08:00">2023-07-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>比例份额算法基于一个简单的想法：调度程序的最终目标，是确保每个工作获得一定比例的 CPU 时间，而不是优化周转时间和响应时间。<br>每隔一段时间，都会举行一次彩票抽奖，以确定接下来应该运行哪个进程。越是应该频繁运行的进程，越是应该拥有更多地赢得彩票的机会。</p>
<h2 id="基本概念：彩票数表示份额"><a href="#基本概念：彩票数表示份额" class="headerlink" title="基本概念：彩票数表示份额"></a>基本概念：彩票数表示份额</h2><p>彩票数代表进程占用资源的份额。</p>
<blockquote>
<p>假设有两个进程 A 和 B，A 拥有 75 张彩票，B 拥有 25 张。因此我们希望 A 占用 75%的 CPU 时间，而 B 占用 25%。</p>
</blockquote>
<p>抽取彩票的过程：</p>
<ol>
<li>调度程序知道总共的彩票数（在我们的例子中，有 100 张）。</li>
<li>调度程序抽取中奖彩票，这是从 0 和 99之间的一个数，拥有这个数对应的彩票的进程中奖。</li>
<li>假设进程 A 拥有 0 到 74 共 75 张彩票，进程 B 拥有 75 到 99 的 25 张，中奖的彩票就决定了运行 A 或 B。</li>
<li>调度程序然后加载中奖进程的状态，并运行它。</li>
</ol>
<p>随机性的优点：</p>
<ul>
<li>随机方法常常可以避免奇怪的边角情况，较传统的算法可能在处理这些情况时遇到麻烦。例如 LRU 替换策略。虽然 LRU 通常是很好的替换算法，但在有重复序列的负载时表现非常差。但随机方法就没有这种最差情况。</li>
<li>随机方法很轻量，几乎不需要记录任何状态。在传统的公平份额调度算法中，记录每个进程已经获得了多少的 CPU 时间，需要对每个进程计时，这必须在每次运行结束后更新。而采用随机方式后每个进程只需要非常少的状态（即每个进程拥有的彩票号码）。</li>
<li>随机方法很快。只要能很快地产生随机数，做出决策就很快。因此，随机方式在对运行速度要求高的场景非常适用。当然，越是需要快的计算速度，随机就会越倾向于伪随机。</li>
</ul>
<h2 id="彩票机制"><a href="#彩票机制" class="headerlink" title="彩票机制"></a>彩票机制</h2><p>彩票货币：允许拥有一组彩票的用户以他们喜欢的某种货币，将彩票分给自己的不同工作。之后操作系统再自动将这种货币兑换为正确的全局彩票。</p>
<blockquote>
<p>假设用户 A 和用户 B 每人拥有 100 张彩票。用户 A 有两个工作 A1 和 A2，他以自己的货币，给每个工作 500 张彩票（共 1000 张）。用户 B 只运行一个工作，给它 10 张彩票（总共 10 张）。操作系统将进行兑换，将 A1 和 A2 拥有的 A 的货币 500 张，兑换成全局货币 50 张。类似地，兑换给 B1 的 10 张彩票兑换成 100 张。然后会对全局彩票货币（共 200张）举行抽奖，决定哪个工作运行。</p>
</blockquote>
<p>彩票转让：一个进程可以临时将自己的彩票交给另一个进程。<br>这种机制在客户端/服务端交互的场景中尤其有用，在这种场景中，客户端进程向服务端发送消息，请求其按自己的需求执行工作，为了加速服务端的执行，客户端可以将自己的彩票转让给服务端，从而尽可能加速服务端执行自己请求的速度。服务端执行结束后会将这部分彩票归还给客户端。</p>
<p>彩票通胀：一个进程可以临时提升或降低自己拥有的彩票数量。<br>当然在竞争环境中，进程之间互相不信任，这种机制就没什么意义。一个贪婪的进程可能给自己非常多的彩票，从而接管机器。但是，通胀可以用于进程之间相互信任的环境。在这种情况下，如果一个进程知道它需要更多 CPU 时间，就可以增加自己的彩票，从而将自己的需求告知操作系统，这一切不需要与任何其他进程通信。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>假定我们用列表记录进程。下面的例子中有 A、B、C 这 3 个进程，每个进程有一定数量的彩票。<br><img src="/2023/07/19/%E6%AF%94%E4%BE%8B%E9%85%8D%E9%A2%9D/1.png"></p>
<p>首先要从彩票总数 400 中选择一个随机数，然后，遍历链表，用一个简单的计数器帮助我们找到中奖者。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// counter: used to track if we&#x27;ve found the winner yet</span></span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// winner: use some call to a random number generator to</span></span><br><span class="line"><span class="comment">// get a value, between 0 and the total # of tickets</span></span><br><span class="line"><span class="type">int</span> winner = getrandom(<span class="number">0</span>, totaltickets);</span><br><span class="line"></span><br><span class="line"><span class="comment">// current: use this to walk through the list of jobs</span></span><br><span class="line"><span class="type">node_t</span> *current = head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// loop until the sum of ticket values is &gt; the winner</span></span><br><span class="line"><span class="keyword">while</span> (current) &#123;</span><br><span class="line">	counter = counter + current-&gt;tickets;</span><br><span class="line">	<span class="keyword">if</span> (counter &gt; winner)</span><br><span class="line">		<span class="keyword">break</span>; <span class="comment">// found the winner</span></span><br><span class="line">	current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;current&#x27; is the winner: schedule it...</span></span><br></pre></td></tr></table></figure>

<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>计算两个互相竞争工作的完成时间，每个工作都有相同数目的 100 张彩票，以及相同的运行时间 R。<br>这种情况下，我们希望两个工作在大约同时完成，但由于彩票调度算法的随机性，有时一个工作会先于另一个完成。为了量化这种区别，我们定义了一个简单的不公平指标 U。将两个工作完成时刻相除得到 U 的值。比如，运行时间 R 为 10，第一个工作在时刻 10 完成，另一个在20，U=10/20=0.5。如果两个工作几乎同时完成，U的值将很接近于 1。在这种情况下，我们的目标是：完美的公平调度程序可以做到 U=1。</p>
<p><img src="/2023/07/19/%E6%AF%94%E4%BE%8B%E9%85%8D%E9%A2%9D/2.png"><br>可以看出，当工作执行时间很短时，平均不公平度非常糟糕。只有当工作执行非常多的时间片时，彩票调度算法才能得到期望的结果。</p>
<h2 id="如何分配彩票"><a href="#如何分配彩票" class="headerlink" title="如何分配彩票"></a>如何分配彩票</h2><p>系统的运行严重依赖于彩票的分配。<br>假设用户自己知道如何分配，因此可以给每个用户一定量的彩票，由用户按照需要自主分配给自己的工作。然而这种方案似乎什么也没有解决——还是没有给出具体的分配策略。因此对于给定的一组工作，彩票分配的问题依然没有最佳答案。</p>
<h2 id="为什么不是确定的"><a href="#为什么不是确定的" class="headerlink" title="为什么不是确定的"></a>为什么不是确定的</h2><p>步长调度：确定性的公平分配算法。<br>系统中的每个工作都有自己的步长，这个值与票数值成反比。</p>
<blockquote>
<p>A、B、C 这 3 个工作的票数分别是 100、50 和 250，我们通过用一个大数分别除以他们的票数来获得每个进程的步长。比如用 10000 除以这些票数值，得到了 3 个进程的步长分别为 100、200 和 40。我们称这个值为每个进程的步长。</p>
</blockquote>
<p>每次进程运行后，我们会让它的计数器（行程值）增加它的步长，记录它的总体进展。<br>之后，调度程序使用进程的步长及行程值来确定调度哪个进程。基本思路很简单：当需要进行调度时，选择目前拥有最小行程值的进程，并且在运行之后将该进程的行程值增加一个步长。</p>
<p>你可能想知道，既然有了可以精确控制的步长调度算法，为什么还要彩票调度算法呢？好吧，彩票调度有一个步长调度没有的优势——不需要全局状态。假如一个新的进程在上面的步长调度执行过程中加入系统，应该怎么设置它的行程值呢？设置成 0 吗？这样的话，它就独占 CPU 了。而彩票调度算法不需要对每个进程记录全局状态，只需要用新进程的票数更新全局的总票数就可以了。因此彩票调度算法能够更合理地处理新加入的进程。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>彩票调度和步长调度。彩票调度通过随机值，聪明地做到了按比例分配。步长调度算法能够确定的获得需要的比例。<br>这两种方式都不能很好地适合 I/O。票数分配问题并没有确定的解决方式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cnhbliyou.github.io/2023/07/15/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%EF%BC%88MLFQ%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="riyuu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="riyuu 的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/15/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%EF%BC%88MLFQ%EF%BC%89/" class="post-title-link" itemprop="url">多级反馈队列（MLFQ）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-15 21:54:01" itemprop="dateCreated datePublished" datetime="2023-07-15T21:54:01+08:00">2023-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-19 15:33:14" itemprop="dateModified" datetime="2023-07-19T15:33:14+08:00">2023-07-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>多级反馈队列是一种操作系统对进程的调度策略</p>
<p>为了解决两个问题：</p>
<ul>
<li>优化周转时间，先执行短工作</li>
<li>降低响应时间，很好的交互体验</li>
</ul>
<p>遇到的问题：通常我们对进程一无所知，应该如 何构建调度程序来实现这些目标？调度程序如何在运行过程中学习进程的特征，从而做出更好的调度决策？</p>
<h2 id="两条基本规则"><a href="#两条基本规则" class="headerlink" title="两条基本规则"></a>两条基本规则</h2><p>有许多独立的队列（queue），每个队列有不同的优先级（priority level）<br>任何时刻，一个工作只能存在于一个队列中<br>总是优先执行较高优先级的工作（即在较 高级队列中的工作）<br>当然，每个队列中可能会有多个工作，因此具有同样的优先级。在这种情况下，我们 就对这些工作采用轮转调度即可解决</p>
<p>关键在于如何设置优先级？根据观察到的行为调整它的优先级<br>如果一个工作不断放弃 CPU 去等待键盘输入，这是交互型进程的可能行为，MLFQ 因此会让它保持高优先级。<br>相反，如果一个工作长时间地占用 CPU，MLFQ 会降低其优先级</p>
<p>在进程运行过程中学习其行为，从而利用工作的历史来预测它未来的行为<br>得到两条基本规则：</p>
<ul>
<li>如果 A 的优先级 &gt; B 的优先级，运行 A（不运行 B）</li>
<li>如果 A 的优先级 = B 的优先级，轮转运行 A 和 B</li>
</ul>
<p>但是只靠这两条规则无法完成调度策略<br><img src="/2023/07/15/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%EF%BC%88MLFQ%EF%BC%89/1.png" alt="MLFQ例子"></p>
<blockquote>
<p>某时刻，最高优先级有两个工作（A 和 B）， 工作 C 位于中等优先级，而 D 的优先级最低<br>按刚才介绍的基本规则，由于 A 和 B 有最高优先级，调度程序将交替的调 度他们<br>可怜的 C 和 D 永远都没有机会运行，太气人了！</p>
</blockquote>
<h2 id="尝试1：如何改变优先级"><a href="#尝试1：如何改变优先级" class="headerlink" title="尝试1：如何改变优先级"></a>尝试1：如何改变优先级</h2><p>优先级与进程的工作负载相关<br>既有运行时间很短、频繁放弃 CPU 的交互型工作<br>也有需要很多 CPU 时间、响应时间却不重要的长时间计算密集型工作</p>
<p>引入3条新规则：</p>
<ul>
<li>工作进入系统时，放在最高优先级（最上层队列）</li>
<li>工作用完整个时间片后，降低其优先级（移入下一个队列）</li>
<li>如果工作在其时间片以内主动释放 CPU， 则优先级不变</li>
</ul>
<blockquote>
<p>A 是一个长时间运行的 CPU 密集型工作，B 是一个运行时间很短的交互型工作。假设 A 执行 一段时间后 B 到达。会发生什么呢？<br>A（用黑色表示）在最低优先级队列执行（长时间运行 的 CPU 密集型工作都这样）。B（用灰色表示）在时间 T=100 时到达，并被加入最高优先级 队列。由于它的运行时间很短（只有 20ms），经过两个时间片，在被移入最低优先级队列之 前，B 执行完毕。然后 A 继续运行（在低优先级）</p>
</blockquote>
<p><img src="/2023/07/15/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%EF%BC%88MLFQ%EF%BC%89/2.png" alt="交互型工作"><br>如果不知道工作是短工作还是长工作，那么就在开始的时候假设其是短工作，并赋予最高优先级。如果确实是短工作，则很快会执行完毕，否则将被慢慢移入低优先级队列，而这时该工作也被认为是长工作了</p>
<p>如果有I/O操作，那么进程通常会主动放弃CPU，保持优先级不变，因为这样可以保持很好的交互性</p>
<p>饥饿（starvation）问题：如果系统有“太多”交互型工作，就会不断占用 CPU，导致长工作永远无法得到 CPU（它们饿死了）。即使在这种情况下，我们希望这些长 工作也能有所进展<br>愚弄调度程序（game the scheduler）：用一些卑鄙的手段欺骗调度程序，让它给你远超公平的资源<br>分类不明确：一个计算密集的进程可能在某段时间表现为 一个交互型的进程</p>
<h2 id="尝试2：提升优先级"><a href="#尝试2：提升优先级" class="headerlink" title="尝试2：提升优先级"></a>尝试2：提升优先级</h2><p>避免饥饿问题，周期性地提升（boost）所有工作的优先级</p>
<ul>
<li>经过一段时间 S，就将系统中所有工作重新加入最高优先级队列</li>
</ul>
<p>首先，进程不会饿死——在最高优先级队列中，它会以轮转的方式，与其他高优先级工作分享 CPU，从而最终获得执行<br>其次，如果一个 CPU 密集型工作变成了交互型，当它优先级提升时，调度程序会正确对待它</p>
<p>添加时间段 S 导致了明显的问题：S 的值应该如何设置？<br>这种值称为“巫毒常量（voo-doo constant）”，因为似乎需要一些黑魔法才能正确设置。如果 S 设置得太高，长工作会饥饿；如果设置得太低，交互型工作又得不到合适的 CPU 时间比例</p>
<h2 id="尝试3：更好的计时方式"><a href="#尝试3：更好的计时方式" class="headerlink" title="尝试3：更好的计时方式"></a>尝试3：更好的计时方式</h2><p>如何阻止调度程序被愚弄？<br>调度程序应该记录一个进程在某一层中消耗的总时间，而不是在调度时重新计时。只要进程用完了自己的配额，就将它降到低一优先级的队列中去。不论它是一次用完的，还是拆成很多次用完</p>
<ul>
<li>一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次 CPU），就降低其优先级（移入低一级队列）</li>
</ul>
<h2 id="MLFQ调优和其他问题"><a href="#MLFQ调优和其他问题" class="headerlink" title="MLFQ调优和其他问题"></a>MLFQ调优和其他问题</h2><p>如何配置一个调度程序，例如， 配置多少队列？每一层队列的时间片配置多大？为了避免饥饿问题以及进程行为改变，应该多久提升一次进程的优先级？</p>
<p>大多数的 MLFQ 变体都支持不同队列可变的时间片长度。高优先级队列通常只有较短的时间片（比如 10ms 或者更少），因而这一层的交互工作可以更快地切换<br>相反，低优先级队列中更多的是 CPU 密集型工作，配置更长的时间片会取得更好的效果</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>有多级队列，并利用反馈信息决定某个工作的优先级。以史为鉴：关注进程的一贯表现，然后区别对待<br>不需要对工作的运行方式有先验知识，而是通过观察工作的运行来给出对应的优先级</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cnhbliyou.github.io/2023/01/10/2022-general-service/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="riyuu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="riyuu 的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/10/2022-general-service/" class="post-title-link" itemprop="url">2022 年通用服务机器人比赛总结和技术文档</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-10 13:30:42" itemprop="dateCreated datePublished" datetime="2023-01-10T13:30:42+08:00">2023-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-19 15:37:59" itemprop="dateModified" datetime="2023-07-19T15:37:59+08:00">2023-07-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2022-年通用服务比赛总结及技术文档"><a href="#2022-年通用服务比赛总结及技术文档" class="headerlink" title="2022 年通用服务比赛总结及技术文档"></a>2022 年通用服务比赛总结及技术文档</h1><h2 id="比赛总结"><a href="#比赛总结" class="headerlink" title="比赛总结"></a>比赛总结</h2><h3 id="比赛规则下载"><a href="#比赛规则下载" class="headerlink" title="比赛规则下载"></a>比赛规则下载</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http</span>:<span class="comment">//crc.drct-caa.org.cn/static/kindeditor/attached/file/20220812/20220812035236_67898.rar</span></span><br></pre></td></tr></table></figure>
<h3 id="整个比赛流程"><a href="#整个比赛流程" class="headerlink" title="整个比赛流程"></a>整个比赛流程</h3><p>  首先每年八月份左右公布规则，然后十月左右结束报名，报名时要把资格认证文档发给组委会邮箱（注意：自己发过去，队里不会帮你发）。</p>
<p>  十一月底开始为期一天的正式比赛，上午第一轮，下午第二轮，比完赛可以当天知道成绩和奖项。</p>
<p>  比赛赛程分两轮，第一轮是全部参赛队伍参加，第二轮是自主报名，主要是对自己第一轮比赛成绩不满意的队伍报名参加。但是报名第二轮的话，第一轮成绩会作废。</p>
<p>  2022 年的比赛大概是 7 月份开始准备，然后 9 月份开始投入比赛准备。</p>
<p>  比赛前两天完成了模型训练</p>
<p>  最终比赛结果是第一轮比赛 110 分，第二轮比赛 0 分。</p>
<p>  第一轮比赛失败原因是：机器人在找人过程中，把一个志愿者当成了两个，导致在采集完第二个志愿者信息后，主程序一直没有收到人脸采集程序的成功信号（因为当前人的信息已经被采集过了，程序会重复进行采集直到成功），程序死机。最终得分包括进场 10 分、找到两个人 60 分、语音交互两个人 40 分。</p>
<p>  第二轮比赛失败原因是：机器人在进场后前往客人房间导航过程中，原本是可通行区域的区域在实际场地中变成了墙体的碰撞区域（原因是最后一次调试后可能墙体被移动了），导致机器人在导航过程中局部路径不可通行，直接原地宕机，直到比赛结束。最终进场的 cmd 点经裁判测量也不符合规则。最终得分 0 分。</p>
<p>  教训：</p>
<ul>
<li>比赛场地在建完地图后不能再动了。</li>
<li>程序应该具有充分的错误处理函数，和完备的测试程序。</li>
<li>尽量保证有两台以上笔记本可以运行比赛程序，不然一个人在调，另一个人只能等。</li>
<li>组委会在上午的比赛中就明确说明西安交通大学每年都 p 事多，所以看我们很不爽，而且在实际比赛中，主裁判也不按发布的规则主持比赛，导致比赛过程中争吵不断。所以我们只能从自己做起，弄好自己能弄的，不然那个主裁判挑刺会导致额外失分。</li>
<li>整个比赛测试流程应该从最开始的模块开始测试，而不是从最重要的模块开始。比如这次比赛，我们先把地图建完，打好航点之后，就先进行了抓取的测试，到我开始测试进场前后的模块时，时间已经来到了早上6点，离比赛开始仅有4个小时。最后比赛证明，出问题的模块几乎都在抓取前面，花费大量心思写完的抓取模块一次都没用到就输了。</li>
</ul>
<h2 id="技术文档"><a href="#技术文档" class="headerlink" title="技术文档"></a>技术文档</h2><p>以下是我们 2022 年的代码仓库地址：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//github.com/XJTU-RoboCup-Club/general_service_2022.git</span></span><br></pre></td></tr></table></figure>

<h3 id="机器人目标"><a href="#机器人目标" class="headerlink" title="机器人目标"></a>机器人目标</h3><p>  我们将比赛要求的每个机器人任务抽象成一个状态，机器人在状态之间进行跳跃，根据状态来执行相应任务，完成比赛目标。具体比赛目标集合见比赛规则。</p>
<p>  注意：发布的比赛规则在后续还会有持续的变化，基本不同裁判对比赛规则也会有不同理解，我们这次就碰到了一个不怎么友好的裁判，一开始就说我们顶撞裁判，然后自顾自地推进他自己的一套比赛流程。</p>
<h3 id="机器人的硬件和软件设计"><a href="#机器人的硬件和软件设计" class="headerlink" title="机器人的硬件和软件设计"></a>机器人的硬件和软件设计</h3><p>  机器人的硬件详细参数见队里的那本说明书</p>
<h4 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h4><ul>
<li>主函数。为 main_service.cpp，主要负责状态的切换和不同节点之间通信的管理，我们自己编写的所有节点都受它控制。</li>
<li>test_face_detection.py，主要负责在走到人面前进行人脸信息的采集，和抓取物品回来之后寻找客人（根据之前的人脸信息对不同客人进行分辨）。使用insight_face 框架，具体使用可以参考官方文档。compreface 经过一定测试发现会占用一个端口号，与 ros 节点端口冲突，导致无法使用，当时我们没有找到解决办法，换成了 insight_face。</li>
<li>test_human_detection.py，主要负责在房间内寻找客人，计算客人面前的地图坐标，然后传回主函数。存在着很多问题：重影问题（有几率会将一个人识别成两个，目前无解决办法，而且一旦出问题，机器人就会卡死，因为它发现当前人在之前就出现过，会判定没找到人脸，然后出发重复判断），找不到人（性能瓶颈，转太快了导致人一闪而过），等等。主要使用 yolo 获取人的 box ，然后推进 mediapipe 里，获取人的关键点，根据几何关系计算人前坐标，发送。</li>
<li>抓取和语音都是集成度高的模块，已经可以满足使用，直接复制粘贴即可。如果有问题，咨询我们（ qq 联系方式：1269406319 ）。</li>
<li>其他模块都比较简单，具体可以看 general_service.launch 里面最后启动的几个节点，就是我们用到的。</li>
<li>整个项目使用 ROS1 编写, 历史遗留问题比较多, 而且没有测试模块, 导致后期测试模块非常麻烦, 建议每个任务都应该配备相应的测试模块, 以方便测试.</li>
<li>模型训练整体非常平稳, 使用 4000 余张 jpg 进行训练, 具体 pt 文件找往届队员（ qq 联系方式：1269406319 ）。模型效果非常好. 几乎每届比赛都不会改物品清单, 如果没变化,直接用往届的就行.</li>
<li>往届代码都会附带注释, 比较详细.</li>
</ul>
<h2 id="附加说明"><a href="#附加说明" class="headerlink" title="附加说明"></a>附加说明</h2><h3 id="关于-insightface-人脸识别"><a href="#关于-insightface-人脸识别" class="headerlink" title="关于 insightface 人脸识别"></a>关于 insightface 人脸识别</h3><p>使用 insightface 的节点为 test_face 节点，在general_service 包里的 test_face.py 文件里实现。</p>
<p>其实主要就是导入库，注册人脸和分类人脸三步。但是这三步所需要输入的图片必须只包含一个人脸，如果没人脸或者多于一个就会报错，所以我们采用选取多个人脸中的最大图片，再输入 insightface 。</p>
<p>register 函数做的是注册人脸的工作，直接调用就行。但是需要注意的一点就是人脸不能重复，当注册已经注册过的人脸时，就会报错，等待新的人脸注册。</p>
<p>recognition 函数做的时是分类工作，输入人脸图，输出注册过的人名。但是需要注意的是，如果输入的人脸没注册过，就会报错输出。</p>
<h3 id="关于-mediapipe-姿态检测"><a href="#关于-mediapipe-姿态检测" class="headerlink" title="关于 mediapipe 姿态检测"></a>关于 mediapipe 姿态检测</h3><p>也分为三部分：导入库，检测出人的特征点框架，计算相对朝向角度。</p>
<p>整个实现代码都在 test_human_detection.py 文件里。</p>
<p>mediapipe_detection 函数是输入图片，输出识别到的特征点框架。需要注意的是，我们再使用前用yolo对图片中的人框一个一个进行 mediapipe_detection ，因为它一次只能识别一个特征点框架。返回的 results 即识别结果，具体包含哪些特征点和信息都需要在官网查看。但是可以肯定的是，只截取图片中人的部分的图片输入函数的正确率远高于将图片中除人部分的颜色通道全置为0（即全部涂黑）高。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//google.github.io/mediapipe/solutions/pose.html</span></span><br></pre></td></tr></table></figure>

<p>关于姿态角度计算，参考文件内的算法实现，这个算法可以计算得比较准确。</p>
<h3 id="关于-slam-的建图使用"><a href="#关于-slam-的建图使用" class="headerlink" title="关于 slam 的建图使用"></a>关于 slam 的建图使用</h3><p>参考队里启智 ROS 机器人开发手册的第三十页和第五十九页。我们都是按照里面的教程进行地图相关工作。</p>
<p>值得注意的问题：</p>
<ul>
<li>这个教程建出来的图我个人感觉有偏差，因为之后总是偏离路线</li>
<li>机器人的初始点得自己设定，需要建图的初始点和当前初始点以及一个参照点进行设定。因为地图启动时，我们机器人在地图上的位置总会偏离固定距离，我们需要自己调好地图文件。</li>
<li>机器人可以在两个门进场，所以需要在命令行启动 launch 文件时就指定当前在哪个门，这个我们在launch文件里已经实现。</li>
<li>参照点的精确性需要重视！！！我们打航点花了近8个小时，最后精确性不怎么样，导致最后机器人卡死在地图墙里，这个得花时间慢慢调。这个与 slam 相关的 move_base 包必须有人会用，得改下 move_base 的东西。比如去年需要一个功能：在导航时如果一段时间没到这个点，就跳过这个点去下一个点，但是没人知道怎么写，造成了很大问题。</li>
<li>如果还有其他问题，欢迎找我们联系。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">riyuu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">riyuu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
